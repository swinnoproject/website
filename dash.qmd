---
pagetitle: "Dashboard *placeholder*"
format:
  html:
    page-layout: full
execute: 
  echo: false
---
## Innovation in the Long Run

The unqiue thing about SWINNO data is that we capture actual innovation.
That means we can track what has been introduced to the market by Swedish companies since 1970.

```{ojs}
Plot.plot({
  marks: [
    Plot.barY(yearly_innovation_count, { x: "year", y: "innovation_count"}),
    Plot.ruleY([0]),
    // Plot.ruleY(yearly_innovation_count, Plot.pointerY({px: "year", y: "innovation_count", stroke: "red"})),
  ],
  x: {
    label: "Year",
    ticks: { interval: 10 }  // Set the interval to 10
  },
  y: { label: "Commercialized Innovation" },
})
```

## Innovation Collaboration

With SWINNO we can analyze the structure and evolution of the Swedish innovation system.
Whenever a source mentions that a commercialized innovation is the result of a collaboration between two or more organizations, we record it.
This can be used to construct a network of innovation collaboration, like the one below.


```{ojs}

chart = ForceGraph(common_graph, {
  nodeId: d => d.id,
  nodeTitle: d => d.id,
  linkStrokeWidth: l => Math.sqrt(l.value),
  width,
  height: 750,
  invalidation // a promise to stop the simulation when the cell is re-run
})

```

:::{.column-margin}
Try zooming in and out of the network, or hover over a circle to see the name of the collaborating organization.
:::

## Interactive Dashboard

Soon you will be able to access our database.
But you can already explore it by using our SWINNO dashboard.
Please note that it can sometimes take a minute to load the dashboard.

<iframe height="100%" width="100%" frameborder="yes" src="https://shinylive.io/py/app/#h=0&code=NobwRAdghgtgpmAXGATAWgCYEsDmWAuA+gAoBOA9hgK4DGRNlcAdDQM4BuYANGAxPnH5JUmXAQAEZSrXziGGOFwCacKKXHkAZnPIx4pGligAbLAC8o+LOQhcGVfgB0IKACxcAjAE4A7AAYuAGZnN09fDy4UEPdvHxQuV2iwn0CgpNiY9N8AVi5srJ8ANkiCnzSXGN8ADgSCr1qKsKqA-MbvKojgtq8q+NbQ9tTE7qr3YYGe4vHKqrLCrKqa-pn6qO6vFqyvCOmwr3i1ia9UrqP3U8qvXKqt4ou9sq8tmo8t+uXIvy-y0JQvnaSfz88XmjSBqVeYK+7h8gK+uUO7iBUzhfjmqJeflR9Xufw8AVBvz8HgiJLhHhB5NShKRxJh5NysKhHmKkKJHjKuOJNSZ7Pquz+fzyIVysQCHlOovCwpcUriXEJcpOIuSSJVsVy4zld3VvjKvLlNRusuSON1zQV5oixpQUt6lpNgy4Nrt53NuUlTWKhzt6MdPRqPqaq11G08oYiQe8+xK-uODVte3cir2mtDxX6Ut8PyzgdD9RTQICQaBpJVQPibIRXyG5ehscTQNFdb8xULX05LZq7b89QldfxnhLxIiTxNeL6A+pA+TA7T4+J3oHZWH3gT1aFhxevk2Lm3PgBe+SBxC++nR4yDpQ+-n1+SxV5+-1p+SL0J+-eL-a4qxF56h7vdp4htbcqghU5QLdP8qmuL9JivUDO2gmoIODcM-zDLc9jLDD4nGbd41Q6M1QwhE4K8HUMJXcju3I-kXyLBNA3+JjPmBVjwR+Zi-BIu8mxlPivgfBiOwE7iajHQTewQz5BwpESSU8X9BIpMTZNrI88SglTcnfWTWQUv0VIkhTP004EAlOPsd0iKzkkjXlrPlQJDick42Sc84POSD1vNiKZ+icspXEC18gkkpycRtayLVccYYs6VymjwpKnVcRymjGVKeg9bKqm9eKmhXPK3xCGK+0K6NxUJaztk8ULo0rGq9ghaKk08DLo1FZro1ZNrozKbwyr2bdhujPtlNWL5izs0sh2GisuAyziUFm+sUG8-i3AWoTPGaoFBraoFA02r5VlCvFLNOxTVp21SPCO4lUhQfa6Uia7RQuxcOruwavoe+aXCmtd8R2oUySBz4Ns8YZAnFGzITh+yGiR2ITwgVHfFSMdMZ8KDcdFRH4aKB1cefDHicxZxcb7ImmnFLpMY6comeA6n4bAmH2cyrgcY53JWiZ4pjSZ6iKaaWjxfaeo+b2SzuejCJQUxmNBfh+NYfVkiVfnFXKJVpCVaWBWvFNlni2m2MkbmtW2PiJlrZrFGLZ49DHb8XWXeF7mDvNti+x94lxUD1TGYtiVndkzJxbxAyY+5N3w5DDHSRsnHU4PFGM8pFPkme6mM-xjPdIL+9SYzv1AgzlDS9iM1c+-LOmgiQXU-tNYq6afOG56Wce-ypv2mC2uAxZtvk87xWrdTmMO5n7vJ9N6PF6uJaR4o6eHmddeeXXifI0txmD+JMe7c3zij7YvvO-42Hj5RXPfZF4-jcfs7y9k+W38U1vZMrUu8SpAdgfDw2sQGMgAd9X+eJh7fxrt-feUNg5v2hh3SsNlYboMzoLLBk4MZYNSDg1UVssFkXwWXTByQxYuTCpQuuMoaGNwdug5mjMWF4MYT0DSnDRgoxYSXch7R9YsLKEQ9okseH1GYdhbegjTZ4Wpug+MYil4MKUbkHGSiMyKK3h4FRPQuZyLNvJchjFQE6LmiYmhi0RYHCdtIoE7hbFsVFGgtirJfzWNElYuxfgqamPfn8CxQdPCIzsYpCGXj7puMAWvAJoDSbhIEVEtswSORxKiTUSheIJ52KFEQwUh5AgQhsg7EpmcOTU3KZWRm5SgFVOITjcpGiGn+T2q0vUnhalhSCRjcp9E+n03eh05moNBlAXqiM56gsSm8I2iM0U3ShHtPGT0QaiNZkmVWVUPsysSlhn7KsuqD0OkxjKS1JSpyYgzNTIDYpexWQbN0R3fZLwXl7D7N0sx5zLFfK+DUhpnEhqDMcZMkF8JPiAt2oc+5vsWRQr8ZC8F0lemwpCcCtFN0fnEnQVCiO5jwUJJQO8vEopYbPW+lYil6TUXUuYni2mULwZ-OhmOeUYp0Lst8NHLlJNIS8oDhALlFo1jCsjM4YV8QujCu7sK9wrRhUCwlSwyiwrYHCqNMqtCoqlGdC1Y1GUXL4z8qUVBI1ZCjXeyFUosoxojX+KNfUO1viGZassQq3xlYdVsQpW6+sBL5RbWlb4q1gbvFst8YGYYYbpKgjDXJON4TSTBr-p4Z16lIjeq0mC+NhM-Usi6fmwaibZJvPzX2D1SCwh+uhnayo-hYx42Rvy+t6Mm2xAhBK+tZr60ei7WXUV9bBr9tiC8EdvgzLtp6OKFtzcGhTvtEyBdhDx28KXTMecC644LvJguyWC765ToOeOmMs7oyysuCRI9FrLhiyPVkk9Aym2MWjbSE+g6z4ftBV+iFP7WycrfXet9+7aSDmlaBlu-aJxxOfU9ADUdyiwb0Y20DD8kNISQw+oVoGZZQYsvO2krLnDkHwAACzgKQZIM7iNkYo820EJHyOUbRtWiAjG6Mdp+mx2jzHuWFu40xnyaaaOCbab09jvGfAri6BJsKwLZP0PkzxoZ8KBMcf-JEVoCmegArU7xzmt09M8xOUZ9on0RPqYHmObTsx+M2dKqZnoAztNhmNC5iITIXPxGs8p89dnfOqL0RZ3jq9DkudZDJgL2Z5mOYMbaYLHzDGybMW55TljUuCcWgS5LTsxk5dduJtLELKlGeRIDfLg0fOZa+FkyE+XVhrBy4OF6CW8Skgy3R6DJmmvuVa29CGTWETDCa6yYbRWaV1fG-S0rxIcS-hy+DLTRXobArAAAXy4OAaA8BhAAEFjDGEIAASQgGx9glhrAQFYCwDg3BeA2AEEIZAKg1AaG0AwPQFHDAmHMBdmwXB9vGHECds7f2rt2HIA4fAzgOWA+B6d8g52rA2FYEtMcsQIhw5B4jsHqOYIw98PELHCOkeXdR9sAnKQAcHfh6D5H4PRiU-cMTunZOlrDA1NToH2PSco95l0NpLOcf09RySNYsQyhC95+DkkHPqhc9p8LtnFI5c+HqFL3HvNjSNw1yLrp6ONO67Z6bAn9ojd89l6b1I5uZfpVN8zmnPPNcUnFzlBXTu9cU4gMsm3ePfxD3dyTzXYFTc1F986f3TnA+s754UV3YZw+uAN3VcPhRQQGvD9kJkfnU+tGItHpXfODwE9XuHtXJfihl8hANAv0vRfAhL2Hx3Qe9f4jz6bdXzeY8M7ZJbcP+JTgsXDzskI-za+a6KKPvw1uu+F-B14cY9Zw89Cn7kfvBKyvD8kqJdfvfEX9+yIcd+-fiWj8HP31wykRzj9by5M-RPZ919CUfiOJ+bRvWX7yYka-H+a4omfyvX-PXSfFwYkSXIA43L-AGZfF-TvbnFvY3RfIUMvd-aGXPZwdbTbSAWABAZAKAAAB3wKYHwIAE87s+BHt8BhAABicQAAH3EFYHwCgAgAwBMBsDgEQHEHwFICoDgGcFoIYI+3wI4P4FYC4OADgGwHwHIEo3EHYCwDgAAHcKMABdZwZwTQCgGARg0jLACAEg8QLAGAEQ0gWQXbQgrgcQKgLATQ7Q3Q-QkgpQrADAHAOAfAVgIwkw2Q2QSHfAfAqgIgZw1w9wqw0gQQBQUgQgYItw6HCAYw0w2QfAlgtgzwqATw-AjAZwBInwjQVgbI7wsw8QfA4wEjYwEgpgOAAAD3wPCNYDSIyKqI0IgFoIAGFwiLsIAcBuDyNxAABxAAVSO2cAIPwMIBsPEAAF5rCsBiCoA3DCBNBjAbCMAAAKZwcQTYmYpgUjDwdYsAAAOSoBgAACMKM3sjCECUdxATjDCXt1AtAdBPsDAjBTALB6dHAwAABKLgDYrYvwgIoIlw2I-Y1gZwhHQgKweAUwCAfg7434iALY7Y7AdgdYxEpErYmwpgfQwEwgVgOAYwOAOgNEjE0k8QT4hgUo0gT4hEskjE4wKAM44wSYz4voigKgfAm4kgmkv4ukzYmgUjcgLAGgOAVgSY4AXkvkpEz433Hk9EqU6UsAD3S7bgkg-AuE2khUxU9AbAPAWQKQagOgHQBQOUrU1QzU0kn4yUpEmgBk+owgFksADANAJY6o8QHAAgtAYIbgSUq0iAL45oigEjKYvIuYsjJgbAUgbbOAVYwgRYrAQkuMgMiAZohQd7cgKkyE8gQgNg5g1Yyk2Qr4xASU8I-AKgKM4ojAJgDojAQgNgVE60-467ZI8MgAKyFIgFWKDPwCsILNIGrLgBKKgBFP2PJO4DHMIE+K+PEAAGoxybt2ApyLSMSMB8A1S4BJiQBPidSxB9SKBDTZB5A4SuCmDSANtfTmiBDxAABldwqwLo6wzk2jG8ijdgCjZwNMxg18ijVYnEwIqwgE-8r8+oy7IsyUgAAUAriKRPAvCNYIo2iOBPcMlM-LBP0LY0hOMIJP0JjLAvlJXMsCgBDL7KzJzMIt-IgEBJYAzNkNWK+OTLpNzKgCYBkLrI4BJIVPIGbMsFIyYHbP0I4q1M2K4rDN4sjOjNjPjMTMIB+MuKor7LooHKHJHM+LHKsM+MnO+NnPnPrM+MbMtP0vEAYrJM0FwBDPwKqKYDUFUEEr5KYqsKqMdPuIuI+30G+zeLBxpJ0CpMmL-PwGoqpLoqsJIMdPsCcDAEMuMtJNMpwCYAZJIL8J2LgFwFI1kGmLhl-DpNLPLMRJisvJaPEF23qLgFOJhO6OfNGJGMIJDIsPwNWNGPGKwCsPxNIDfNIGTMwK2xwOEGVJsEhPXIXPIIe0ECoOe1UAePTOePct+3py4F6sRLXPVIhyh0p3FCWmzxsm7gx08GdFd0zmVG90Jx2sWEpylXKE42tGryxiCHOr4w80jybQ0k51HD2o9HQjaVJDGTaS2s6U+oes5AaFHR2opAF3l07UOrVx2pX0OotGTQ2otB+tGV5nTw0wOomU+tBvtHBqdFJDiitxusxpiCHFdxgmOvhrerlwHg8wNwHmxrWR2p8G13ppXRhpeDR1Dxuqup2R2sKC5pxHetNjWtcCZrDDpuOQVDlzqh+tPTyElrOtBuNQVHjxOFuoXx5vbzVvPC6gZo2tXmltZCWkjw3jFsGl5mTwBoVrZvxElpQgFuMXWpL35sX2+FJC+Cn0sh+BYmtH6BYg0iyyWj3zOp9unyhr3xVsH1dlHEJHrG7n4j+tXxuudoNpOtAP-XBrhSUmjrRBuuDqtsCC-0RQhGDr7FCSzv5ujrki6UHzAziTa2BpQG30UgOq62fzPwhFLrbs5pfyJuODP3OATG-1DrPzep9oLSVigLuF5jP1NpTpgRusbrZsZ1AIBlSHfxBmdArv5tQLWuL1AKFHqT3tJDyG32hnPHW1UKAA">  </iframe>



<!-- Load Data and Functions for OJS -->
```{ojs}
d3 = require("d3@7")
```

```{ojs}
common_graph = FileAttachment("data/common_graph.json").json()
```

```{ojs}
yearly_innovation_count = FileAttachment("data/swinno_count.txt").csv()
```

```{ojs}
// Copyright 2021-2023 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/force-directed-graph
function ForceGraph({
  nodes, // an iterable of node objects (typically [{id}, …])
  links // an iterable of link objects (typically [{source, target}, …])
}, {
  nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)
  nodeGroup, // given d in nodes, returns an (ordinal) value for color
  nodeGroups, // an array of ordinal values representing the node groups
  nodeTitle, // given d in nodes, a title string
  nodeFill = "currentColor", // node stroke fill (if not using a group color encoding)
  nodeStroke = "#fff", // node stroke color
  nodeStrokeWidth = 5, // node stroke width, in pixels
  nodeStrokeOpacity = 1, // node stroke opacity
  nodeRadius = 10, // node radius, in pixels
  nodeStrength,
  linkSource = ({source}) => source, // given d in links, returns a node identifier string
  linkTarget = ({target}) => target, // given d in links, returns a node identifier string
  linkStroke = "#999", // link stroke color
  linkStrokeOpacity = 0.6, // link stroke opacity
  linkStrokeWidth = 30, // given d in links, returns a stroke width in pixels
  linkStrokeLinecap = "round", // link stroke linecap
  linkStrength,
  colors = d3.schemeTableau10, // an array of color strings, for the node groups
  width = 450, // outer width, in pixels
  height = 450, // outer height, in pixels
  zoomExtent = [0.1, 10],
  invalidation // when this promise resolves, stop the simulation
} = {}) {
  // Compute values.
  const N = d3.map(nodes, nodeId).map(intern);
  const LS = d3.map(links, linkSource).map(intern);
  const LT = d3.map(links, linkTarget).map(intern);
  if (nodeTitle === undefined) nodeTitle = (_, i) => N[i];
  const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
  const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);
  const W = typeof linkStrokeWidth !== "function" ? null : d3.map(links, linkStrokeWidth);
  const L = typeof linkStroke !== "function" ? null : d3.map(links, linkStroke);

  // Replace the input nodes and links with mutable objects for the simulation.
  nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
  links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i]}));

  // Compute default domains.
  if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);

  // Construct the scales.
  const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

  // Construct the forces.
  const forceNode = d3.forceManyBody();
  const forceLink = d3.forceLink(links).id(({index: i}) => N[i]);
  if (nodeStrength !== undefined) forceNode.strength(nodeStrength);
  if (linkStrength !== undefined) forceLink.strength(linkStrength);

  const simulation = d3.forceSimulation(nodes)
      .force("link", forceLink)
      .force("charge", forceNode)
      .force("center",  d3.forceCenter())
      .on("tick", ticked);

  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

   const zoom = d3.zoom()
      .scaleExtent(zoomExtent)
      .on("zoom", zoomed);

  svg.call(zoom, d3.zoomIdentity.scale(zoomExtent[0]));

  const link = svg.append("g")
      .attr("stroke", typeof linkStroke !== "function" ? linkStroke : null)
      .attr("stroke-opacity", linkStrokeOpacity)
      .attr("stroke-width", typeof linkStrokeWidth !== "function" ? linkStrokeWidth : null)
      .attr("stroke-linecap", linkStrokeLinecap)
    .selectAll("line")
    .data(links)
    .join("line");

  const node = svg.append("g")
      .attr("fill", nodeFill)
      .attr("stroke", nodeStroke)
      .attr("stroke-opacity", nodeStrokeOpacity)
      .attr("stroke-width", nodeStrokeWidth)
    .selectAll("circle")
    .data(nodes)
    .join("circle")
      .attr("r", nodeRadius)
      .call(drag(simulation));

  if (W) link.attr("stroke-width", ({index: i}) => W[i]);
  if (L) link.attr("stroke", ({index: i}) => L[i]);
  if (G) node.attr("fill", ({index: i}) => color(G[i]));
  if (T) node.append("title").text(({index: i}) => T[i]);
  if (invalidation != null) invalidation.then(() => simulation.stop());

  function intern(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);
  }

  function drag(simulation) {    
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
    
    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }
    
    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
    
    return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
  }

function zoomed(event) {
    const { transform } = event;
    link.attr("transform", transform);
    node.attr("transform", transform);
}

  return Object.assign(svg.node(), {scales: {color}});
}
```
